import rospy
import gym
from gym import error, spaces
from gym.utils import seeding
from gazebo_connection import GazeboConnection
from controllers_connection import ControllersConnection
#https://bitbucket.org/theconstructcore/theconstruct_msgs/src/master/msg/RLExperimentInfo.msg
from theconstruct_msgs.msgs import RLExperimentInfo

# https://github.com/openai/gym/blob/master/gym/core.py
class RobotGazeboEnv(gym.Env):
    #def __init__(self, model_path, initial_qpos, n_actions, n_substeps):
    def __init__(self, n_actions):

        # To reset Simulations
        self.gazebo_sim = GazeboConnection()
        self.controllers_object = ControllersConnection(namespace="cartpole_v0")
        self.seed()
        #self.action_space = spaces.Box(-1., 1., shape=(n_actions,), dtype='float32')
        self.action_space = spaces.Discrete(n_actions)
        # Visualization system
        self.viewer = None

        # Set up ROS related variables
        self.reward_pub = rospy.Publisher('/openai/reward', RLExperimentInfo, queue_size=1)

    # Env methods
    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def step(self, action):
        """
        Function executed each time step.
        Here we get the action execute it in a time step and retrieve the
        observations generated by that action.
        :param action:
        :return: obs, reward, done, info
        """


        """
        Here we should convert the action num to movement action, execute the action in the
        simulation and get the observations result of perfroming that action.
        """
        self._set_action(action)
        # Here we implement the Unpause, get data and pause again that we now to explicitly
        self.gazebo_sim.step()
        self._step_callback()
        obs = self._get_obs()

        done = self._is_done(obs)
        info = {}
        reward = self._compute_reward(obs, done)
        self._publish_reward_topic(reward)

        return obs, reward, done, info

    def reset(self):
        did_reset_sim = False
        while not did_reset_sim:
            did_reset_sim = self._reset_sim()
        obs = self._get_obs()
        return obs

    def close(self):
        """
        Function executed when closing the environment.
        Use it for closing GUIS and other systems that need closing.
        :return:
        """
        if self.viewer is not None:
            # self.viewer.finish()
            self.viewer = None

    def render(self, mode='no_view'):
        self._render_callback()
        if mode == 'rgb_array':
            self._get_viewer().render()
            # window size used for old mujoco-py:
            width, height = 500, 500
            data = self._get_viewer().read_pixels(width, height, depth=False)
            # original image is upside-down, so flip it
            return data[::-1, :, :]
        elif mode == 'human':
            self._get_viewer().render()
        elif mode == 'no_view':
            pass

    def _get_viewer(self):
        if self.viewer is None:
            # TODO: Implement the ScreenShot recording system, possibly through screenshots of a camera
            # TODO: Or maybe we could also record a 3D video data, OpenGL maybe?
            # http://wiki.ros.org/RecordingOpenGLAppsWithGLC
            # http://answers.gazebosim.org/question/7116/forcing-gazebo-to-render-at-fixed-intervals-or-how-to-record-a-video-of-a-simulation/
            self.viewer = self.gazebo_sim.GazeboViewer()
            self._viewer_setup()
        return self.viewer

    # Extension methods
    # ----------------------------

    def _reset_sim(self):
        """Resets a simulation and indicates whether or not it was successful.
        If a reset was unsuccessful (e.g. if a randomized state caused an error in the
        simulation), this method should indicate such a failure by returning False.
        In such a case, this method will be called again to attempt a the reset again.
        """
        # TODO: Implement the reset algorithm
        self.gazebo_sim.set_state(self.initial_state)
        self.gazebo_sim.resetSim()
        return True

    def _get_obs(self):
        """Returns the observation.
        """
        raise NotImplementedError()

    def _set_action(self, action):
        """Applies the given action to the simulation.
        """
        raise NotImplementedError()

    def _is_success(self, achieved_goal, desired_goal):
        """Indicates whether or not the achieved goal successfully achieved the desired goal.
        """
        raise NotImplementedError()

    def _is_done(self, observations):
        """Indicates whether or not the episode is done ( the robot has fallen for example).
        """
        raise NotImplementedError()

    def _compute_reward(self, observations, done):
        """Calculates the reward to give based on the observations given.
        """
        raise NotImplementedError()

    def _publish_reward_topic(self, reward, episode_number=1):
        """
        This function publishes the given reward in the reward topic for
        easy access from ROS infrastructure.
        :param reward:
        :param episode_number:
        :return:
        """
        reward_msg = RLExperimentInfo()
        reward_msg.episode_number = episode_number
        reward_msg.episode_reward = reward
        self.reward_pub.publish(reward_msg)


    def _sample_goal(self):
        """Samples a new goal and returns it.
        """
        raise NotImplementedError()

    def _env_setup(self, initial_qpos):
        """Initial configuration of the environment. Can be used to configure initial state
        and extract information from the simulation.
        """
        pass

    def _viewer_setup(self):
        """Initial configuration of the viewer. Can be used to set the camera position,
        for example.
        """
        pass

    def _render_callback(self):
        """A custom callback that is called before rendering. Can be used
        to implement custom visualizations.
        """
        pass

    def _step_callback(self):
        """A custom callback that is called after stepping the simulation. Can be used
        to enforce additional constraints on the simulation state.
        """
        pass